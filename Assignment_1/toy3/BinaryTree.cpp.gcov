        -:    0:Source:BinaryTree.cpp
        -:    0:Graph:BinaryTree.gcno
        -:    0:Data:BinaryTree.gcda
        -:    0:Runs:1
        -:    1:#include "BinaryTree.h"
        -:    2:
       38:    3:BinaryTree::Node::Node(int x) : value(x) {}
        -:    4:
       38:    5:void BinaryTree::add(int value) {
       38:    6:    Node *new_node = new Node(value);
       38:    7:    if (m_root == nullptr) {
        4:    8:        m_root = new_node;
        4:    9:        return;
        -:   10:    }
        -:   11:
       34:   12:    Node *node = m_root;
        -:   13:
        -:   14:    while (true) {
      104:   15:        if (value <= node->value) {
       51:   16:            if (node->left == nullptr) {
       18:   17:                node->left = new_node;
       18:   18:                return;
        -:   19:            }
       33:   20:            node = node->left;
        -:   21:        } else {
       53:   22:            if (node->right == nullptr) {
       16:   23:                node->right = new_node;
       16:   24:                return;
        -:   25:            }
       37:   26:            node = node->right;
        -:   27:        }
        -:   28:    }
        -:   29:}
        -:   30:
        2:   31:BinaryTree::Node *BinaryTree::remove_smallest(Node **root_ptr) {
        2:   32:    Node **parent_slot = root_ptr;
        2:   33:    Node *node = *root_ptr;
        -:   34:
        4:   35:    while (node->left != nullptr) {
        2:   36:        parent_slot = &node->left;
        2:   37:        node = *parent_slot;
        -:   38:    }
        -:   39:
        2:   40:    *parent_slot = nullptr;
        2:   41:    return node;
        -:   42:}
        -:   43:
        2:   44:BinaryTree::Node *BinaryTree::remove_largest(Node **root_ptr) {
        2:   45:    Node **parent_slot = root_ptr;
        2:   46:    Node *node = *root_ptr;
        -:   47:
        4:   48:    while (node->right != nullptr) {
        2:   49:        parent_slot = &node->right;
        2:   50:        node = *parent_slot;
        -:   51:    }
        -:   52:
        2:   53:    *parent_slot = nullptr;
        2:   54:    return node;
        -:   55:}
        -:   56:
       10:   57:bool BinaryTree::remove(int value) {
       10:   58:    Node **parent_slot = &m_root;
       10:   59:    Node *node = m_root;
        -:   60:
       18:   61:    while (node != nullptr) {
       13:   62:        if (value == node->value) {
        5:   63:            Node *replacement = nullptr;
        -:   64:
        5:   65:            if (node->right != nullptr) {
        2:   66:                replacement = remove_smallest(&node->right);
        3:   67:            } else if (node->left != nullptr) {
        2:   68:                replacement = remove_largest(&node->left);
        -:   69:            }
        -:   70:
        5:   71:            if (replacement != nullptr) {
        4:   72:                replacement->left = node->left;
        4:   73:                replacement->right = node->right;
        -:   74:            }
        5:   75:            *parent_slot = replacement;
        5:   76:            delete node;
        5:   77:            return true;
        8:   78:        } else if (value <= node->value) {
        5:   79:            parent_slot = &node->left;
        -:   80:        } else {
        3:   81:            parent_slot = &node->right;
        -:   82:        }
        8:   83:        node = *parent_slot;
        -:   84:    }
        -:   85:
        5:   86:    return false;
        -:   87:}
