        -:    0:Source:LinkedList.cpp
        -:    0:Graph:LinkedList.gcno
        -:    0:Data:LinkedList.gcda
        -:    0:Runs:1
        -:    1:#include "LinkedList.h"
        -:    2:
        7:    3:LinkedList::Node::Node(int x) : value (x) {}
        -:    4:
        6:    5:LinkedList::Node *LinkedList::get_node(size_t idx) {
        6:    6:    if (idx >= m_size) {
        2:    7:        return nullptr;
        -:    8:    }
        -:    9:
        -:   10:    LinkedList::Node *node;
        4:   11:    if (idx < m_size/2) {
        1:   12:        node = m_head;
        2:   13:        for (size_t i = 0; i < idx; i++) {
        1:   14:            node = node->next;
        -:   15:        }
        -:   16:    } else {
        3:   17:        node = m_tail;
        4:   18:        for (size_t i = m_size-1; i > idx; i--) {
        1:   19:            node = node->prev;
        -:   20:        }
        -:   21:    }
        4:   22:    return node;
        -:   23:}
        -:   24:
        1:   25:size_t LinkedList::size() {
        1:   26:    return m_size;
        -:   27:}
        -:   28:
        3:   29:void LinkedList::push_front(int value) {
        3:   30:    LinkedList::Node *node = new Node(value);
        3:   31:    if (m_size++ == 0) {
        1:   32:        m_tail = node;
        -:   33:    } else {
        2:   34:        m_head->prev = node;
        2:   35:        node->next = m_head;
        -:   36:    }
        3:   37:    m_head = node;
        3:   38:}
        -:   39:
        4:   40:void LinkedList::push_back(int value) {
        4:   41:    LinkedList::Node *node = new Node(value);
        4:   42:    if (m_size++ == 0) {
        2:   43:        m_head = node;
        -:   44:    } else {
        2:   45:        m_tail->next = node;
        2:   46:        node->prev = m_tail;
        -:   47:    }
        4:   48:    m_tail = node;
        4:   49:}
        -:   50:
        2:   51:int LinkedList::operator[](size_t idx) {
        2:   52:    LinkedList::Node *node = get_node(idx);
        2:   53:    if (node == nullptr) {
        1:   54:        throw std::out_of_range("invalid list index");
        -:   55:    }
        1:   56:    return node->value;
        -:   57:}
        -:   58:
        4:   59:bool LinkedList::erase(size_t idx) {
        4:   60:    LinkedList::Node *node = get_node(idx);
        4:   61:    if (node == nullptr) {
        1:   62:        return false;
        -:   63:    }
        -:   64:
        3:   65:    if (node->prev == nullptr) {
        1:   66:        m_head = node->next;
        -:   67:    } else {
        2:   68:        node->prev->next = node->next;
        -:   69:    }
        -:   70:
        3:   71:    if (node->next == nullptr) {
        2:   72:        m_tail = node->prev;
        -:   73:    } else {
        1:   74:        node->next->prev = node->prev;
        -:   75:    }
        -:   76:
        3:   77:    m_size--;
        3:   78:    delete node;
        -:   79:
        3:   80:    return true;
        -:   81:}
